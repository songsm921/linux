# 2주차 활동 보고서
## 목표
1. ZCU106 Board LED control을 통해 전반적인 보드의 사용법 숙지 (Tutorial)
2. Petalinux에서 Gpio LED address를 찾아 direct로 LED control

## 1. ZCU106 Board LED control을 통해 전반적인 보드의 사용법 숙지
> Xilinx ZCU106 Board에 내장되어 있는 LED를 Xilinx Vivado, Vitis를 활용하여 control하는 것이다. Google에 관련 보드를 검색해보면 연관검색어에 'led blinking'이 상단에 나올만큼 SoC를 처음 접하는 자들에게는 일종의 통과 Tutorial로 여겨지는 듯하다. 방법은 크게 다음과 같다.
 - Vivado의 Xilinx가 제공하는 IP를 이용하여 하드웨어 로직을 구성하고, Vitis로 로직 및 SW 구성. cf) 로직 및 SW 구성을 pass하고 verilog module에서 통제도 가능하다.
### A. Only LED
```verilog
module ledclk(input clk, output reg [2:0] LED);
    reg [26:0]counter;
    always @(posedge clk) begin
        if(counter>=27'd125000000) begin
            if(LED == 3'b111) begin
                LED <= 0;
            end
            else begin
                LED <= LED + 1;
            end
            counter <= 0;
        end
        else begin
            counter <= counter + 1;
        end
    end
endmodule
/***********************************************/
module div(input [2:0] LED, output reg LED_1, output reg LED_2, output reg LED_3);
    always @(*) begin
        LED_1 = LED[0];
        LED_2 = LED[1];
        LED_3 = LED[2];
    end
endmodule
```
> verilog 코드는 간단하다. Simulation에서와 달리 SoC에서는 Clock를 사용자가 처음부터 정의해서 사용할 수 없고, time을 navie하게 verilog로 통제하는 것은 어려움이 예상되어 register를 선언하여 counter를 만들어 주었다. 125MHZ의 클락을 사용할 수 있는 것을 알아내어 counter가 12500000000 이상이 되면 LED의 불이 하나씩 늘어나게 하였다. 이후 counter는 초기화하여 다음 1초를 count한다. <br>
> Div Module은 Vivado에서 ledclk모듈을 block diagram으로 뽑아 내었을 때, 3개의 output line을 각각 뽑아내지 못하여 이를 분리해주는 Module을 추가로 구성하였다. 분명 이를 분리하여 output을 뽑을 수 있을텐데, 숙지가 미숙하여 일단 cost의 손해를 보면서 module을 구성하였다. <br>
> 다음은 Block Diagram이다.
![BD1](./BD1.png) <br><br>
> Clocking Wizard를 사용하여 기존 SoC에서 제공하는 Clock을 설계자 의도대로 분주하여 나눌 수 있도록 모듈을 구성하였다. ledclk에 들어가는 clk의 frequency는 125MHZ이다. 위를 이용하여 LED 한개의 control과 여러개까지 control를 할 수 있었다.
### B. LED control with Push button
```cpp
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xgpio.h"
#include "xil_types.h"
#include "xparameters.h"
#define BTN_ID XPAR_GPIO_0_DEVICE_ID
#define LED_ID XPAR_GPIO_1_DEVICE_ID
#define BTN_CHANNEL 1
#define LED_CHANNEL 1
#define BTN_MASK 0b11111
#define LED_MASK 0b11111111
int main()
{
	XGpio_Config *cfg_ptr;
	XGpio led_device, btn_device;
	u32 data;
	cfg_ptr = XGpio_LookupConfig(LED_ID);
	XGpio_CfgInitialize(&led_device,cfg_ptr,XPAR_GPIO_1_BASEADDR);
	cfg_ptr = XGpio_LookupConfig(BTN_ID);
	XGpio_CfgInitialize(&btn_device,cfg_ptr,XPAR_GPIO_0_BASEADDR);
	XGpio_SetDataDirection(&btn_device,BTN_CHANNEL,BTN_MASK);
	XGpio_SetDataDirection(&led_device,LED_CHANNEL,0);
	while(1){
		data = XGpio_DiscreteRead(&btn_device,BTN_CHANNEL);
		data &= BTN_MASK;
		if(data!=0){
			data = LED_MASK;
		}
		else{
			data = 0;
		}
		XGpio_DiscreteWrite(&led_device,LED_CHANNEL,data);
	}
	return 0;
}
```
> 이번에는 보드에 내장되어 있는 버튼을 누르면 LED가 켜지도록 구현해보았다. 전체적인 프로세스는 먼저 vivado에서 IP를 사용하여 로직을 디자인하고, 이를 vitis로 넘어와서 이 로직에 대하여 통제하는 code를 작성해준다. 이때, AXI Gpio라는 interface를 사용하여 구현의 난이도가 낮아진다. 이렇게 하지 않는다면 Verilog level에서 button, led 연결 및 통제, 보드와의 연결을 모두 verilog로 해주어야 하는데, 이를 보다 익숙한 c++로 할 수 있다는 것은 큰 장점이다. 게다가, Vivado에서 디자인 한 것을 bitstream으로 만들어 vitis에서 연동하면 자동으로 interface의 주소등을 Header file에 구성해준다. 아래는 로직 디자인과 언급한 header file의 모습이다. <br>
![logic](./logic.png)
![headerfile](./header.png) <br><br>
> 이후 Vitis에서 application을 build하고, Program device 후 run on hardware를 작동시켜주면 보드에서 결과물을 볼 수 있다.
### C. Discussion
1. Constraint File
> Xilinx에서는 보드를 출시하면서 보드의 각종 interface를 매핑시켜주는 파일을 제공한다. 아래의 그림과 같다.
![constraint](./constraint.png) <br>
> 이러한 파일의 존재를 모르고 있다면 일일히 수작업으로 매핑시켜줘야 하므로 난이도가 상승한다. 이 파일의 사용법은 크게 두가지로 숙지했다. 
 - 1. Vivado design에서 port를 생성하고 해당 port 이름을 constraint file에 명시되어 있는 이름으로 설정한다. 
 - 2. Constraint file의 "get_ports" 뒤의 이름을 설계자의 의도대로 변경한다. 4번째 Led에 매핑시키고 싶다면 "Gpio...."를 led[3]으로 바꾸는 형식이다.
2. JTAG BOOT mode & Board Initialization
> JTAG BOOT mode 등 3가지의 boot mode가 존재한다. 이를 설정해주기 위해서는 보드의 4개짜리 스위치를 설정해주어야 하는데, 우리가 보통 아는 off와 on의 고정관념으로 인해 착오가 발생하였다. 메뉴얼을 정독하자. 또한, Program Device를 진행할 때, 보드 우상단 부분의 LED 들어오는 곳의 'DONE'이라는 곳이 빨간 불이 진행되지 않는다. 이때는 보드를 껏다가 다시 키거나, Xilinx에 있는 보드 초기화 과정을 거치고 진행하면 해결할 수 있다.

## 2. PetaLinux에서 memory mapping을 통한 LED Control
> Petalinux는 일종의 Embedded Operating System으로 이해하였다. 보드와 자신이 디자인 하드웨어 로직을 적용하여 리눅스를 빌드하여 보드를 제어할 수 있다. 이 또한 LED를 제어하여 Petalinux의 숙지와 더 나아가 목표하는 Device driver의 기초를 시작해 볼 수 있다.
### A. Petalinux Build
> Petalinux의 빌드는 회사 내의 가이드라인을 사용하였다. 여기서 주의해야 하는 점은 Petalinux를 Petalinux 본연 자체로 사용할 수도 있고, Ubuntu를 곁들여서 사용할 수도 있는데, 이때의 update과정에서 주의할 점이 존재한다. 보드에 Petalinux를 올릴 때 SD카드를 넣어 부팅하는 방식을 택하는데, 이때 SD카드는 두개의 파티션으로 나누어진다. Ext4 file system의 root file system, fat32 file system의 부트 섹터로 나누어진다. Ubuntu를 사용하면 root file system은 ubuntu로, 부트 섹터는 petalinux에서 빌드한 부트 이미지를 이용하는데, petalinux에 g++, ssh를 추가하여 build할 때 이들은 root file system에 적용되는 사항인데 root file system은 ubuntu로 구분되어 이는 update되지 않는다. 따라서, 시행착오를 겪은 후에 ubuntu를 버리고 petalinux 자체를 사용하기로 하였다. Petalinux 자체의 root file system은 project 파일의 image/linux/rootfs.tar 파일에 압축되어 있으며 이를 ext4 partition에 extract하여 사용하면 된다. 두 system의 차이점은 Ubuntu를 사용하여 GUI를 사용 할 수 있다는 점이고, Petalinux는 GUI가 완벽하지 않아 CLI로 하는 것이 용이하다는 점이 차이점이다.
### B. Linux System (Device Driver)
> LED에 접근하기 위해 먼저 Linux의 /sys/class/ 디렉토리를 조사하게 되었다. 이 디렉토리에는 많은 device들이 존재하는데, 우리가 다루게 될 Gpio와 LED도 존재한다. LED는 heartbeat, keyboard등이 존재하는데 heartbeat는 board의 1초를 주기로 깜박거리는 led를 말하며 일종의 상태등인듯 하다. Keyboard는 capslock, numlock등 누르면 불이 들어오는 것을 제어한다. 안에는 trigger, brightness등의 파일이 존재하는데, Trigger에는 현재 연결되어 있는 device들의 trigger가 모두 존재하는 것 같다. Heartbeat의 trigger를 kbd-capslock으로 바꾸면 capslock을 눌렀을 때 보드의 불이 들어오게 할 수 있었기 때문이다. Trigger를 none으로 echo하고 brightness를 0 또는 1로 echo하면 불을 끄거나 킬 수 있다. Gpio 부분은 아직 이해가 덜 되었지만, Gpio 핀 개별로 제어 할 수 없게 막아 놓은 듯 하다. 따라서, 이를 직접 제어하고 싶다면 핀 번호를 알아내어 "echo 핀번호 > export" 명령어를 치면 해당 디렉토리에 있는 export script에 의해 gpio#이라는 폴더가 만들어지고, 이 폴더안에서 해당 핀의 입출력을 변경할 수 있으며, value를 assign하여 led의 경우 불을 끄거나 킬 수 있을 듯하다. 또한 label을 확인하여 해당 핀이 찾는 핀인지 주소로 확인할 수 있다. 하지만, 아직 켜고자 하는 gpio led는 찾지 못하였다. 위 원인은 두 가지를 생각 해볼 수 있는데, 그저 못 찾았거나, 아니면 petalinux를 빌드할 때 내가 짠 하드웨어 로직이 반영이 안된 것이다. 하지만, 뒤에 언급할 mmap으로 인해 그저 못 찾았다는 것으로 가닥이 잡히고 있다.
### C. Mmap을 이용한 device (LED) 제어
> 초기에 접근하고자 했던 방법인 linux 상의 Device 파일을 직접 제어하는 것은 실패하였다. 그렇다면, 주소로 접근 할 수는 없을까? 다행스럽게도, Vivado에서 IP를 설정할 때 절대 주소를 알 수 있다. 이 IP는 Petalinux를 구성 할 때 device-tree에 속하며, /dev/mem에 mapping되어 있을 것이다. 이 가정을 가지고 간단한 code를 짜서 LED에 접근하고자 한다. 아래는 해당 code이다.
```cpp
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#define GPIO_BASE 0x00A0000000
#define LEN 65535

int main()
{
    int fd = open("/dev/mem",O_RDWR|O_SYNC);
    if(fd<0){
        printf("OPEN FAILED!\n");
        exit(-1);
    }
    char *gpio_memory_map = (char*)mmap(0,LEN,PROT_READ|PROT_WRITE,MAP_SHARED,fd,GPIO_BASE);
    if(gpio_memory_map == MAP_FAILED)
    {
        printf("MAPPING FAILED!\n");
        exit(-1);
    }
    for(int i = 0; i<255;i++)
    {
        *gpio_memory_map = i; // when i = 16 -> 10000(2)
        sleep(1);
    }
    munmap(gpio_memory_map,LEN);
    return 0;
} 
```
> GPIO_BASE, 즉 LED는 0x00A0000000에 있으면 LEN은 master highest address - base address로 계산하여 정하였다. 먼저, /dev/mem을 열어 File descriptor를 지정하고, 이 file descriptor에서 mmap을 해준다. LED는 8개이며 0 또는 1의 값을 가질 것이므로 8bit일 것이다. 2^8 = 256의 경우의 수가 존재하며 이를 확인하기 위해 0 ~ 255값을 넣어 모든 불이 들어오는 것을 확인하였다. 여기서 추가로 알게 된 점은, windows의 Sleep() function의 단위는 ms이며, linux 상의 sleep() function의 단위는 sec이다.
### D. Control LED by using devmem command
> 이번에는 devmem 명령어를 사용하여 LED를 제어해보았다. devmem 내부가 어떻게 작동하는지는 정확히는 모르겠지만, 추측에 의하면 위의 소스 코드를 명령어화 해놓은 듯하다. Parameter는 devmem [addr] [width] [value] 이며, 위 경우에는 "devmem 0x00A0000000 8 0~255"를 넣어 확인하였다. 명확하지 않은 점은, width가 8의 배수만을 유효한 값으로 받는다는 것이다. 이로써 direct하게 절대 주소를 통하여 I/O를 제어해보았다.
### E. Discussion
1. Safety?
> 이렇게 하는 것이 과연 OS 전체 관리 측면에서 안전한가에 대한 의문이 생겼다. 적어도 windows에서 이와 같은 행동을 하는 것은 못보았고, 쉽지 않을 것 같은데, linux는 주로 하는 행동은 아니더라도 비교적 방법이 쉬워 보안 측면에서 의문점이 들었다. 물론, 절대 주소가 알고 있지 않다면 이와 같은 방법은 효율적이지는 못하겠지만, /dev/mem 파일을 열어서 분석하면 위험하지 않을까 라는 생각을 하게 되었다. 학교에서 OS 수업을 들을 때, 상당 부분을 사용자가 직접 접근하는 것을 방지하기 위해 capsulation, abstraction이 구현되었다고 얼핏 들은 것 같은데, device driver도 같은 맥락이지 않을까, 사용자가 직접 접근하는 것을 막으면서 간접적으로 제어할 수 있게 interface를 제공하는 것인가에 대하여 생각해보게 되었다.
2. Linux System
> Linux root file system에 대해 공부해볼 필요성을 느끼게 되었다. 양이 방대하여 일단 이번에 다룬 부분부터 책을 읽으며 접근하고, 만약 이 부분이 어느정도 잡힌다고 생각이 들면 부트섹터에 대해 공부해보고 싶다. 애초에 현재 사용하는 환경인 windows + ubuntu 환경에서 grub이 먼저 뜨는 것도 의문이다. 무언가 은연중에 드는 생각은 windows의 부트로더가 더 강력하여 grub이 안 뜨고 windows가 부팅 우선 순위를 잡아 먹을 것 같은데, 설치 할 때 무언가 설정을 해주었던 것 같기도 하다. 또한, 이전에는 부트 순서를 변경 할 때 CMOS, BIOS라는 단어가 많이 나왔던 것 같은데, 요즈음에는 UEFI boot라는 단어가 대다수인 것 같다. 느낀 차이점으로는 전자는 keyboard 입력만 가능하며 그래픽이 조금 투박했던 것 같은데, UEFI로 넘어 오면서 setting 화면이 굉장히 세련되고 마우스 입력이 가능해졌다. 물론, 이것이 두 boot 방식의 차이점은 아니겠지만 잘 모르는 상태에서 와닿는 차이점은 이점이다.
